var documenterSearchIndex = {"docs":
[{"location":"generated/droop_identification/#Droop-Identification-Example","page":"Droop Identification","title":"Droop Identification Example","text":"","category":"section"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"using NormalFormIdentification\nusing NetworkDynamics\nusing PowerDynamics\nusing PowerDynamics.Library\nusing CairoMakie\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt","category":"page"},{"location":"generated/droop_identification/#Basic-droop-inverter-model","page":"Droop Identification","title":"Basic droop inverter model","text":"","category":"section"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"@mtkmodel DroopInverter begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Wirkleistungs-Sollwert\", guess=1]\n        Qset, [description=\"Blindleistungs-Sollwert\", guess=0]\n        Vset, [description=\"Spannungs-Sollwert\", guess=1]\n        ω₀=0, [description=\"Nennfrequenz\"]\n        Kp=1.0, [description=\"Wirkleistungs-Droop-Koeffizient\"]\n        Kq=1.0, [description=\"Blindleistungs-Droop-Koeffizient\"]\n        τ = 1.0, [description=\"Zeitkonstante des Leistungsfilters\"]\n    end\n    @variables begin\n        Pmeas(t), [description=\"Wirkleistungsmessung\", guess=1]\n        Qmeas(t), [description=\"Blindleistungsmessung\", guess=0]\n        Pfilt(t), [description=\"Gefilterte Wirkleistung\", guess=1]\n        Qfilt(t), [description=\"Gefilterte Blindleistung\", guess=1]\n        ω(t)=1, [description=\"Frequenz\"]\n        δ(t)=0, [description=\"Spannungswinkel\", guess=0]\n        V(t)=1, [description=\"Spannungsbetrag\"]\n    end\n    @equations begin\n        Pmeas ~  terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Qmeas ~ -terminal.u_r*terminal.i_i + terminal.u_i*terminal.i_r\n        τ * Dt(Pfilt) ~ Pmeas - Pfilt\n        τ * Dt(Qfilt) ~ Qmeas - Qfilt\n        ω ~ ω₀ - Kp * (Pfilt - Pset) ## Frequenz senken, wenn P höher als Sollwert\n        V ~ Vset - Kq * (Qfilt - Qset) ## Spannung senken, wenn Q höher als Sollwert\n        Dt(δ) ~ ω - ω₀\n        terminal.u_r ~ V*cos(δ)\n        terminal.u_i ~ V*sin(δ)\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Build the bus model","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"@named inverter = DroopInverter()\nmtkbus = MTKBus(inverter)\nvm = Bus(mtkbus)\nnothing #hide","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"in order to get the LTI we need to initialize the system","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"set_default!(vm, :busbar₊u_r, 1.0)\nset_default!(vm, :busbar₊u_i, 0.0)\nset_default!(vm, :busbar₊i_r, -1.0)\nset_default!(vm, :busbar₊i_i, 0.0)\ninitialize_component!(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Now we have a fully initialzied model and can inspectit further","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_equations(vm; remove_ns=[:inverter])","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_linearization(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Next we can generate the bode plots for","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G(s) = C  left(sM -Aright)^-1B","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).G)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Also the slighly adapted Gs","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G_s(s) = scdot G(s) = s cdot C  left(sM -Aright)^-1B","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).Gs)","category":"page"},{"location":"generated/droop_identification/#Droop-Inverter-behind-resistance","page":"Droop Identification","title":"Droop Inverter behind resistance","text":"","category":"section"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"<details>\n<summary>Click to expand, but maybe ignore this section for now...</summary>","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"@mtkmodel DroopInverterResistance begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Wirkleistungs-Sollwert\", guess=1]\n        Qset, [description=\"Blindleistungs-Sollwert\", guess=0]\n        Vset, [description=\"Spannungs-Sollwert\", guess=1]\n        ω₀=0, [description=\"Nennfrequenz\"]\n        Kp=1.0, [description=\"Wirkleistungs-Droop-Koeffizient\"]\n        Kq=1.0, [description=\"Blindleistungs-Droop-Koeffizient\"]\n        τ = 1.0, [description=\"Zeitkonstante des Leistungsfilters\"]\n        R = 1, [description=\"Widerstand der internen Impedanz\", guess=1]\n    end\n    @variables begin\n        Pmeas(t), [description=\"Wirkleistungsmessung\", guess=1]\n        Qmeas(t), [description=\"Blindleistungsmessung\", guess=0]\n        Pfilt(t), [description=\"Gefilterte Wirkleistung\", guess=1]\n        Qfilt(t), [description=\"Gefilterte Blindleistung\", guess=1]\n        ω(t)=1, [description=\"Frequenz\"]\n        δ(t)=0, [description=\"Spannungswinkel\", guess=0]\n        V(t)=1, [description=\"Spannungsbetrag\"]\n        u_r(t), [description=\"Spannung intern\", guess=1]\n        u_i(t), [description=\"Spannung intern\", guess=0]\n    end\n    @equations begin\n        terminal.i_r ~ (u_r - terminal.u_r) / R\n        terminal.i_i ~ (u_i - terminal.u_i) / R\n        Pmeas ~  u_r*terminal.i_r + u_i*terminal.i_i\n        Qmeas ~ -u_r*terminal.i_i + u_i*terminal.i_r\n        τ * Dt(Pfilt) ~ Pmeas - Pfilt\n        τ * Dt(Qfilt) ~ Qmeas - Qfilt\n        ω ~ ω₀ - Kp * (Pfilt - Pset) ## Frequenz senken, wenn P höher als Sollwert\n        V ~ Vset - Kq * (Qfilt - Qset) ## Spannung senken, wenn Q höher als Sollwert\n        Dt(δ) ~ ω - ω₀\n        u_r ~ V*cos(δ)\n        u_i ~ V*sin(δ)\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Now let's build and analyze this model with internal resistance.","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"@named inverter = DroopInverterResistance()\nmtkbus = MTKBus(inverter)\nvm = Bus(mtkbus)\nset_default!(vm, :busbar₊u_r, 1.0)\nset_default!(vm, :busbar₊u_i, 0.0)\nset_default!(vm, :busbar₊i_r, -1.0)\nset_default!(vm, :busbar₊i_i, 0.0)\ninitialize_component!(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Let's examine the equations and linearization of this model:","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_equations(vm; remove_ns=[:inverter])","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_linearization(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"note: Pseudo Inverse\nFor this model we use the pinv instead of inv for the calculation of G and Gs!","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Next we can generate the bode plots for","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G(s) = C  left(sM -Aright)^daggerB","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).G_pinv)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Also the slighly adapted Gs","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G_s(s) = scdot G(s) = s cdot C  left(sM -Aright)^daggerB","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).Gs_pinv)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"</details>","category":"page"},{"location":"generated/droop_identification/#Droop-with-Resistance-over-Capacitance","page":"Droop Identification","title":"Droop with Resistance over Capacitance","text":"","category":"section"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"This model is very similar to the last one, but has an explicit DGL for the voltage and thus no constraints.","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"@mtkmodel DroopInverterCapacitance begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Wirkleistungs-Sollwert\", guess=1]\n        Qset, [description=\"Blindleistungs-Sollwert\", guess=0]\n        Vset, [description=\"Spannungs-Sollwert\", guess=1]\n        ω₀=0, [description=\"Nennfrequenz\"]\n        Kp=1.0, [description=\"Wirkleistungs-Droop-Koeffizient\"]\n        Kq=1.0, [description=\"Blindleistungs-Droop-Koeffizient\"]\n        τ = 1.0, [description=\"Zeitkonstante des Leistungsfilters\"]\n        R = 1, [description=\"Widerstand der internen Impedanz\", guess=1]\n        C = 1, [description=\"Kapazität der internen Impedanz\", guess=1]\n    end\n    @variables begin\n        Pmeas(t), [description=\"Wirkleistungsmessung\", guess=1]\n        Qmeas(t), [description=\"Blindleistungsmessung\", guess=0]\n        Pfilt(t), [description=\"Gefilterte Wirkleistung\", guess=1]\n        Qfilt(t), [description=\"Gefilterte Blindleistung\", guess=1]\n        ω(t), [description=\"Frequenz\"]\n        δ(t), [description=\"Spannungswinkel\", guess=0]\n        V(t), [description=\"Spannungsbetrag\"]\n        u_r(t), [description=\"Spannung intern\", guess=1]\n        u_i(t), [description=\"Spannung intern\", guess=0]\n        i_r(t), [description=\"Strom intern\", guess=0]\n        i_i(t), [description=\"Strom intern\", guess=0]\n    end\n    @equations begin\n        i_r ~ (u_r - terminal.u_r) / R\n        i_i ~ (u_i - terminal.u_i) / R\n        # the factor of 1 is normally ω0 but depends on the units of C\n        Dt(terminal.u_r) ~  1*terminal.u_i + 1/C * (i_r + terminal.i_r)\n        Dt(terminal.u_i) ~ -1*terminal.u_r + 1/C * (i_i + terminal.i_i)\n\n        Pmeas ~  u_r*terminal.i_r + u_i*terminal.i_i\n        Qmeas ~ -u_r*terminal.i_i + u_i*terminal.i_r\n        τ * Dt(Pfilt) ~ Pmeas - Pfilt\n        τ * Dt(Qfilt) ~ Qmeas - Qfilt\n        ω ~ ω₀ - Kp * (Pfilt - Pset) ## Frequenz senken, wenn P höher als Sollwert\n        V ~ Vset - Kq * (Qfilt - Qset) ## Spannung senken, wenn Q höher als Sollwert\n        Dt(δ) ~ ω - ω₀\n        u_r ~ V*cos(δ)\n        u_i ~ V*sin(δ)\n    end\nend;\n\n@named inverter = DroopInverterCapacitance()\nmtkbus = MTKBus(inverter)\nvm = Bus(mtkbus)\nset_default!(vm, :busbar₊u_r, 1.0)\nset_default!(vm, :busbar₊u_i, 0.0)\nset_default!(vm, :busbar₊i_r, -1.0)\nset_default!(vm, :busbar₊i_i, 0.0)\ninitialize_component!(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"First, we check the rotational symmetry of the steadystate. I.e. we rotate inputs and ouputs and also the covariant state delta and check if the steadystate is still a steady state under thos conditions.","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"rotational_symmetry(vm; covariant=[:inverter₊δ])","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Let's examine the equations and linearization of this model:","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_equations(vm; remove_ns=[:inverter])","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"print_linearization(vm)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Next we can generate the bode plots for","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G(s) = C  left(sM -Aright)^-1B","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).G)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"Also the slighly adapted Gs","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"G_s(s) = scdot G(s) = s cdot C  left(sM -Aright)^-1B","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"bode_plot(get_LTI(vm).Gs)","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"","category":"page"},{"location":"generated/droop_identification/","page":"Droop Identification","title":"Droop Identification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#NormalFormIdentification","page":"Home","title":"NormalFormIdentification","text":"","category":"section"},{"location":"generated/ieee9bus/#Linearization-of-Models-in-IEEE-9-Bus-System","page":"IEEE 9-Bus Linearization","title":"Linearization of Models in IEEE 9-Bus System","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"In this example, we'll substitute dynamic models with their Normal Form (NF) linearization and validate that the linearized models remain accurate under global phase shifts.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"In PowerDynamics.jl, we start with a nonlinear dynamical system of the form","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  fracdmathbfxdt = fleft(mathbfx mathbfiright)\n  mathbfu = g(mathbfx)\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"where mathbfu is the complex voltage output and mathbfi is the complex current input.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"However, for linearization it's more convenient to work with power-phase variables rather than voltage-current variables. To transform this into the normal form convention mathbfDelta S mapsto mathbfDelta Theta, we need to reformulate the system as","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  fracdmathbfxdt = fleft(mathbfx left(fracmathbfSg(mathbfx)right)^*right) = barf(mathbfx mathbfS)\n  mathbfTheta = mathrmlng(mathbfx) = barg(mathbfx)\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Next, we identify the equilibrium point around which we want to linearize the system:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  fracdmathbfxdt = 0 = f(mathbfx_0 mathbfi_0)\n    mathbfu_0 = g(mathbfx_0)\n  mathbfS_0 = mathbfu_0 cdot mathbfi_0^*\n  mathbfTheta_0 = mathrmlng(mathbfx_0) = mathrmlnmathbfu_0\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"The linearization around the equilibrium point looks liek this:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  fracdmathbfxdt = underbracebarf(mathbfx_0 mathbfS_0)_=0 + fracpartial barfpartial mathbfxbigg_mathbfx_0 mathbfS_0delta mathbfx +\n  fracpartial barfpartial mathbfSbigg_mathbfx_0 mathbfS_0deltamathbfS\n  mathbfTheta = mathbfTheta_0 + fracpartial bargpartial mathbfxbigg_mathbfx_0 delta mathbfx\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"where the partial derivatives form the system matrices. This gives us the Linear Time-Invariant (LTI) normal form","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  fracddeltamathbfxdt = mathbfAdelta mathbfx + mathbfBdeltamathbfS\n  mathbfTheta = mathbfTheta_0 + mathbfCdelta mathbfx\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"This LTI could be the basis for further model reduction emthods, like Balanced Truncation.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"To integrate this linearized model with the original PowerDynamics framework, we need to provide a wrapper that translates between the original voltage-current variables and our new power-phase formulation:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"beginaligned\n  deltamathbfS = mathbfi^*left(expleft(mathbfTheta_0 + mathbfCdelta mathbfxright)right) - mathbfS_0\n  fracdmathbfxdt = mathbfAdelta mathbfx + mathbfBdeltamathbfS\n  mathbfu = expleft(mathbfTheta_0 + mathbfCdelta mathbfxright)\nendaligned","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"From these equations, we observe that the output voltage mathbfu depends only on the internal state deviations deltamathbfx and the initial phase angles mathbfTheta_0. This means that under a global phase shift (rotation of all phase angles by the same amount), only the initial phase mathbfTheta_0i needs to be updated—making it the only covariant variable.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"To demonstrate and validate this rotational invariance property, we use the IEEE 9-bus test system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"using PowerDynamics\nusing NormalFormIdentification\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing Graphs\nusing CairoMakie\nusing BenchmarkTools","category":"page"},{"location":"generated/ieee9bus/#Setting-up-the-IEEE-9-Bus-Test-System","page":"IEEE 9-Bus Linearization","title":"Setting up the IEEE 9-Bus Test System","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"First, we load the IEEE 9-Bus system from PowerDynamics and compute the steady-state powerflow:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"include(joinpath(pkgdir(PowerDynamics), \"test\", \"testsystems.jl\"))\nnw = TestSystems.load_ieee9bus()\n\npfnw = powerflow_model(nw)\npf0 = NWState(pfnw)\npfs = find_fixpoint(pfnw, pf0)\nnothing # hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"To test the rotational invariance of our linearization approach, we create a second powerflow state where we rotate the slack bus reference angle by 30 degrees. This represents a global phase shift of the entire system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"pf0_rot = NWState(pfnw)\npf0_rot[VPIndex(1, :slack₊δ)] = deg2rad(30)\npfs_rot = find_fixpoint(pfnw, pf0_rot)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Comparing the two powerflow results confirms that they differ only by the applied global phase shift, while all other system properties remain identical:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"show_powerflow(pfs)","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"show_powerflow(pfs_rot)","category":"page"},{"location":"generated/ieee9bus/#Reference-Simulation-with-Nonlinear-Models","page":"IEEE 9-Bus Linearization","title":"Reference Simulation with Nonlinear Models","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"To establish a reference solution, we simulate a line trip contingency using the full nonlinear models. This will serve as our benchmark for comparing the linearized model accuracy.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"We initialize the network from both powerflow states (with and without phase shift) and simulate the system response over 10 seconds.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"# Perturbation: line failure of 4=>6 at t=1s\ndeactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx\n    p[:pibranch₊active] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(nw[EIndex(4=>6)], cb)\n\n# steady states for both rotated and non-rotated case\ns0 = initialize_from_pf(nw; pfs=pfs)\ns0_rot = initialize_from_pf(nw; pfs=pfs_rot)\n\n# simulation of both rotated and non-rotated case\nprob = ODEProblem(nw, uflat(s0), (0.0, 10.0), copy(pflat(s0)), callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P());\n\nprob_rot = ODEProblem(nw, uflat(s0_rot), (0.0, 10.0), copy(pflat(s0_rot)), callback=get_callbacks(nw))\nsol_rot = solve(prob_rot, Rodas5P());\n\n# Verify that the solutions differ by exactly the phase shift\n@assert sol_rot(0; idxs=VIndex(1,:busbar₊u_arg)) - sol(0; idxs=VIndex(1,:busbar₊u_arg)) ≈ deg2rad(30)\n\n# Plotting results\nlet\n    fig = Figure(size=(600,800));\n\n    # Active power at selected buses\n    ax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), alpha=0.5)\n        lines!(ax, sol_rot; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n    end\n\n    # Voltage magnitude at all buses\n    ax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), alpha=0.5)\n        lines!(ax, sol_rot; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n    end\n\n    fig\nend","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"As expected, both voltage magnitudes and active power profiles are identical for both cases. This confirms that these quantities are indeed invariant under global phase shifts.","category":"page"},{"location":"generated/ieee9bus/#Complete-System-Linearization","page":"IEEE 9-Bus Linearization","title":"Complete System Linearization","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Now we proceed to linearize all dynamic components around their respective operating points. This involves computing the Normal Form linearization for each component using the steady-state conditions we established above.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"# Helper function to extract component state from network state\nfunction get_component_state(s::NWState, cidx)\n    nw = extract_nw(s)\n    comp = nw[cidx]\n    allsym = vcat(sym(comp), psym(comp), insym(comp), outsym(comp))\n    Dict(sym => s[VIndex(cidx.compidx, sym)] for sym in allsym)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"We apply the Normal Form linearization procedure to each of the 9 bus components, computing the linearized dynamics around their respective operating points:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"vms_lin = map(1:9) do i\n    nonlinear_model = nw[VIndex(i)]\n    comp_state = get_component_state(s0, VIndex(i))\n    nf_linearization(nonlinear_model, comp_state)\nend;\nnw_lin = Network(nw; vertexm=vms_lin)","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"The linearized network is then initialized using both the original and phase-shifted powerflow states. By simulating both cases, we can verify whether the linearized models preserve the rotational invariance property of the original nonlinear system:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"s0_lin = initialize_from_pf(nw_lin; pfs=pfs);\nprob_lin = ODEProblem(nw_lin, uflat(s0_lin), (0.0, 10.0), copy(pflat(s0_lin)), callback=get_callbacks(nw_lin))\nsol_lin = solve(prob_lin, Rodas5P());\n\ns0_lin_rot = initialize_from_pf(nw_lin; pfs=pfs_rot);\nprob_lin_rot = ODEProblem(nw_lin, uflat(s0_lin_rot), (0.0, 10.0), copy(pflat(s0_lin_rot)), callback=get_callbacks(nw_lin))\nsol_lin_rot = solve(prob_lin_rot, Rodas5P());\n\nlet\n    fig = Figure(size=(600,800));\n\n    # Active power at selected buses\n    ax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), alpha=0.3)\n        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n        lines!(ax, sol_lin_rot; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), linewidth=0.5)\n    end\n\n    # Voltage magnitude at all buses\n    ax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), alpha=0.3)\n        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n        lines!(ax, sol_lin_rot; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), linewidth=0.5)\n    end\n\n    fig\nend","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"The plot displays three overlapping traces for each bus (same color per bus):","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Transparent solid line: Original nonlinear model\nDashed line: Linearized model initialized from non-rotated powerflow\nThin solid line: Linearized model initialized from rotated powerflow","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"The agreement between the two normal furm curves demostrate, that the linearization in invariant coordinates keeps the global phase shift symmetry.","category":"page"},{"location":"generated/ieee9bus/#Excursion:-Rotational-Symmetry-Analysis","page":"IEEE 9-Bus Linearization","title":"Excursion: Rotational Symmetry Analysis","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"In the original generator model, the machine angle δ is covariant (it transforms along with global phase shifts). We can verify this numerically by applying a rotation to all relevant variables and checking that the steady-state residual remains zero:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"rotational_symmetry(nw[VIndex(1)], get_component_state(s0, VIndex(1));\n    covariant=[:generator₊machine₊δ])","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"In the linearized Normal Form model, the covariant variable is the initial phase angle Θ₀_i, while the rest of the states remain invariant.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"rotational_symmetry(nw_lin[VIndex(1)], get_component_state(s0_lin, VIndex(1));\n    covariant=[:Θ₀_i])","category":"page"},{"location":"generated/ieee9bus/#Selective-Linearization:-Generators-Only","page":"IEEE 9-Bus Linearization","title":"Selective Linearization: Generators Only","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"In the previous example, we linearized all system components, including simple Kirchhoff junction buses and PQ load buses that have relatively simple dynamics. For comparison, let's now create a hybrid model where we linearize only the three generator buses (which have complex dynamics) while keeping the remaining buses in their original nonlinear form.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"vms_lin2 = map(1:9) do i\n    if i ∈  [1,2,3]\n        nonlinear_model = nw[VIndex(i)]\n        comp_state = get_component_state(s0, VIndex(i))\n        nf_linearization(nonlinear_model, comp_state)\n    else\n        copy(nw[VIndex(i)])\n    end\nend;\nnw_lin2 = Network(nw; vertexm=vms_lin2)\ns0_lin2 = initialize_from_pf(nw_lin2; pfs=pfs);\nprob_lin2 = ODEProblem(nw_lin2, uflat(s0_lin2), (0.0, 10.0), copy(pflat(s0_lin2)), callback=get_callbacks(nw_lin2))\nsol_lin2 = solve(prob_lin2, Rodas5P());\n\nlet\n    fig = Figure(size=(600,800));\n\n    # Active power at selected buses\n    ax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), alpha=0.3)\n        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n        lines!(ax, sol_lin2; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i), linewidth=0.5)\n    end\n\n    # Voltage magnitude at all buses\n    ax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\n    for i in 1:9\n        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), alpha=0.3)\n        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), linestyle=:dash)\n        lines!(ax, sol_lin2; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i), linewidth=0.5)\n    end\n\n    fig\nend","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"This selective linearization approach yields results that are even closer to the full nonlinear solution. This suggests that linearizing only the components with significant dynamic complexity can provide an optimal balance between computational efficiency and accuracy.","category":"page"},{"location":"generated/ieee9bus/#Computational-Performance-Analysis","page":"IEEE 9-Bus Linearization","title":"Computational Performance Analysis","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Finally, let's quantify the computational benefits of linearization by benchmarking the different model variants. We'll measure both the single function evaluation time and the complete ODE solve performance.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"dx = zeros(dim(nw)); x = copy(uflat(s0)); p = copy(pflat(s0));\n@benchmark $nw($dx, $x, $p, 0.0) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"dx = zeros(dim(nw_lin)); x = copy(uflat(s0_lin)); p = copy(pflat(s0_lin));\n@benchmark $nw_lin($dx, $x, $p, 0.0) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"dx = zeros(dim(nw_lin2)); x = copy(uflat(s0_lin2)); p = copy(pflat(s0_lin2));\n@benchmark $nw_lin2($dx, $x, $p, 0.0) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"Next, we benchmark the complete ODE solution process:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"@benchmark solve($prob, Rodas5P()) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"@benchmark solve($prob_lin, Rodas5P()) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"@benchmark solve($prob_lin2, Rodas5P()) seconds=1","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"The results here are... inconclusive. For this system there is no real benefit in linearizing.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Linearization","title":"IEEE 9-Bus Linearization","text":"This page was generated using Literate.jl.","category":"page"}]
}
