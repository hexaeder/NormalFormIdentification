<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IEEE 9-Bus Linearization · NormalFormIdentification.jl</title><meta name="title" content="IEEE 9-Bus Linearization · NormalFormIdentification.jl"/><meta property="og:title" content="IEEE 9-Bus Linearization · NormalFormIdentification.jl"/><meta property="twitter:title" content="IEEE 9-Bus Linearization · NormalFormIdentification.jl"/><meta name="description" content="Documentation for NormalFormIdentification.jl."/><meta property="og:description" content="Documentation for NormalFormIdentification.jl."/><meta property="twitter:description" content="Documentation for NormalFormIdentification.jl."/><meta property="og:url" content="https://hexaeder.github.io/NormalFormIdentification.jl/generated/ieee9bus/"/><meta property="twitter:url" content="https://hexaeder.github.io/NormalFormIdentification.jl/generated/ieee9bus/"/><link rel="canonical" href="https://hexaeder.github.io/NormalFormIdentification.jl/generated/ieee9bus/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NormalFormIdentification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../droop_identification/">Droop Identification</a></li><li class="is-active"><a class="tocitem" href>IEEE 9-Bus Linearization</a><ul class="internal"><li><a class="tocitem" href="#Setting-up-the-IEEE-9-Bus-Test-System"><span>Setting up the IEEE 9-Bus Test System</span></a></li><li><a class="tocitem" href="#Reference-Simulation-with-Nonlinear-Models"><span>Reference Simulation with Nonlinear Models</span></a></li><li><a class="tocitem" href="#Complete-System-Linearization"><span>Complete System Linearization</span></a></li><li><a class="tocitem" href="#Excursion:-Rotational-Symmetry-Analysis"><span>Excursion: Rotational Symmetry Analysis</span></a></li><li><a class="tocitem" href="#Selective-Linearization:-Generators-Only"><span>Selective Linearization: Generators Only</span></a></li><li><a class="tocitem" href="#Computational-Performance-Analysis"><span>Computational Performance Analysis</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>IEEE 9-Bus Linearization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IEEE 9-Bus Linearization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hexaeder/NormalFormIdentification" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hexaeder/NormalFormIdentification/blob/main/docs/examples/ieee9bus.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linearization-of-Models-in-IEEE-9-Bus-System"><a class="docs-heading-anchor" href="#Linearization-of-Models-in-IEEE-9-Bus-System">Linearization of Models in IEEE 9-Bus System</a><a id="Linearization-of-Models-in-IEEE-9-Bus-System-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization-of-Models-in-IEEE-9-Bus-System" title="Permalink"></a></h1><p>In this example, we&#39;ll substitute dynamic models with their Normal Form (NF) linearization and validate that the linearized models remain accurate under global phase shifts.</p><p>In PowerDynamics.jl, we start with a nonlinear dynamical system of the form</p><p class="math-container">\[\begin{aligned}
  \frac{d\mathbf{x}}{dt} &amp;= f\left(\mathbf{x}, \mathbf{i}\right)\\
  \mathbf{u} &amp;= g(\mathbf{x})
\end{aligned}\]</p><p>where <span>$\mathbf{u}$</span> is the complex voltage output and <span>$\mathbf{i}$</span> is the complex current input.</p><p>However, for linearization it&#39;s more convenient to work with power-phase variables rather than voltage-current variables. To transform this into the normal form convention <span>$\mathbf{\Delta S} \mapsto \mathbf{\Delta \Theta}$</span>, we need to reformulate the system as</p><p class="math-container">\[\begin{aligned}
  \frac{d\mathbf{x}}{dt} &amp;= f\left(\mathbf{x}, \left(\frac{\mathbf{S}}{g(\mathbf{x})}\right)^*\right) &amp;&amp;= \bar{f}(\mathbf{x}, \mathbf{S})\\
  \mathbf{\Theta} &amp;= \mathrm{ln}\,g(\mathbf{x}) &amp;&amp;= \bar{g}(\mathbf{x})
\end{aligned}\]</p><p>Next, we identify the equilibrium point around which we want to linearize the system:</p><p class="math-container">\[\begin{aligned}
  \frac{d\mathbf{x}}{dt} &amp;= 0 = f(\mathbf{x}_0, \mathbf{i}_0)\\
    \mathbf{u}_0 &amp;= g(\mathbf{x}_0)\\
  \mathbf{S}_0 &amp;= \mathbf{u}_0 \cdot \mathbf{i}_0^*\\
  \mathbf{\Theta}_0 &amp;= \mathrm{ln}\,g(\mathbf{x}_0) = \mathrm{ln}\,\mathbf{u}_0
\end{aligned}\]</p><p>The linearization around the equilibrium point looks liek this:</p><p class="math-container">\[\begin{aligned}
  \frac{d\mathbf{x}}{dt} &amp;= \underbrace{\bar{f}(\mathbf{x}_0, \mathbf{S}_0)}_{=0} + \frac{\partial \bar{f}}{\partial \mathbf{x}}\bigg|_{\mathbf{x}_0, \mathbf{S}_0}\delta \mathbf{x} +
  \frac{\partial \bar{f}}{\partial \mathbf{S}}\bigg|_{\mathbf{x}_0, \mathbf{S}_0}\delta\mathbf{S}\\
  \mathbf{\Theta} &amp;= \mathbf{\Theta}_0 + \frac{\partial \bar{g}}{\partial \mathbf{x}}\bigg|_{\mathbf{x}_0} \delta \mathbf{x}
\end{aligned}\]</p><p>where the partial derivatives form the system matrices. This gives us the Linear Time-Invariant (LTI) normal form</p><p class="math-container">\[\begin{aligned}
  \frac{d\delta\mathbf{x}}{dt} &amp;= \mathbf{A}\,\delta \mathbf{x} + \mathbf{B}\,\delta\mathbf{S}\\
  \mathbf{\Theta} &amp;= \mathbf{\Theta}_0 + \mathbf{C}\,\delta \mathbf{x}
\end{aligned}\]</p><p>This LTI could be the basis for further model reduction emthods, like Balanced Truncation.</p><p>To integrate this linearized model with the original PowerDynamics framework, we need to provide a wrapper that translates between the original voltage-current variables and our new power-phase formulation:</p><p class="math-container">\[\begin{aligned}
  \delta\mathbf{S} &amp;= \mathbf{i}^*\left(\exp\left(\mathbf{\Theta}_0 + \mathbf{C}\,\delta \mathbf{x}\right)\right) - \mathbf{S}_0\\
  \frac{d\mathbf{x}}{dt} &amp;= \mathbf{A}\,\delta \mathbf{x} + \mathbf{B}\,\delta\mathbf{S}\\
  \mathbf{u} &amp;= \exp\left(\mathbf{\Theta}_0 + \mathbf{C}\,\delta \mathbf{x}\right)
\end{aligned}\]</p><p>From these equations, we observe that the output voltage <span>$\mathbf{u}$</span> depends only on the internal state deviations <span>$\delta\mathbf{x}$</span> and the initial phase angles <span>$\mathbf{\Theta}_0$</span>. This means that under a global phase shift (rotation of all phase angles by the same amount), only the initial phase <span>$\mathbf{\Theta}_{0,i}$</span> needs to be updated—making it the only covariant variable.</p><p>To demonstrate and validate this rotational invariance property, we use the IEEE 9-bus test system.</p><pre><code class="language-julia hljs">using PowerDynamics
using NormalFormIdentification
using OrdinaryDiffEqRosenbrock
using OrdinaryDiffEqNonlinearSolve
using Graphs
using CairoMakie
using BenchmarkTools</code></pre><h2 id="Setting-up-the-IEEE-9-Bus-Test-System"><a class="docs-heading-anchor" href="#Setting-up-the-IEEE-9-Bus-Test-System">Setting up the IEEE 9-Bus Test System</a><a id="Setting-up-the-IEEE-9-Bus-Test-System-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-IEEE-9-Bus-Test-System" title="Permalink"></a></h2><p>First, we load the IEEE 9-Bus system from PowerDynamics and compute the steady-state powerflow:</p><pre><code class="language-julia hljs">include(joinpath(pkgdir(PowerDynamics), &quot;test&quot;, &quot;testsystems.jl&quot;))
nw = TestSystems.load_ieee9bus()

pfnw = powerflow_model(nw)
pf0 = NWState(pfnw)
pfs = find_fixpoint(pfnw, pf0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Order of edge models was changed to match the natural ordering of edges in graph (as in `edges(g)`)! Concretely, this means that `nw[EIndex(1)]` references the first edge from `edges(g)` **and not necessarily the first edge model in the provided list**. Disable warning with kw `warn_order=false`.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ NetworkDynamics ~/.julia/packages/NetworkDynamics/mCEnB/src/construction.jl:280</span></code></pre><p>To test the rotational invariance of our linearization approach, we create a <strong>second powerflow state</strong> where we rotate the slack bus reference angle by 30 degrees. This represents a global phase shift of the entire system.</p><pre><code class="language-julia hljs">pf0_rot = NWState(pfnw)
pf0_rot[VPIndex(1, :slack₊δ)] = deg2rad(30)
pfs_rot = find_fixpoint(pfnw, pf0_rot)</code></pre><p>Comparing the two powerflow results confirms that they differ only by the applied global phase shift, while all other system properties remain identical:</p><pre><code class="language-julia hljs">show_powerflow(pfs)</code></pre><div><div style = "float: left;"><span>9×6 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">N</th><th style = "text-align: left;">Bus Names</th><th style = "text-align: left;">vm [pu]</th><th style = "text-align: left;">varg [deg]</th><th style = "text-align: left;">P [pu]</th><th style = "text-align: left;">Q [pu]</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Symbol" style = "text-align: left;">Symbol</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">1</td><td style = "text-align: left;">slackbus</td><td style = "text-align: right;">1.04</td><td style = "text-align: right;">0.0</td><td style = "text-align: right;">0.71641</td><td style = "text-align: right;">0.270459</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">2</td><td style = "text-align: left;">pvbus</td><td style = "text-align: right;">1.025</td><td style = "text-align: right;">9.28001</td><td style = "text-align: right;">1.63</td><td style = "text-align: right;">0.0665366</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">3</td><td style = "text-align: left;">pvbus</td><td style = "text-align: right;">1.025</td><td style = "text-align: right;">4.66475</td><td style = "text-align: right;">0.85</td><td style = "text-align: right;">-0.108597</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">4</td><td style = "text-align: left;">bus4</td><td style = "text-align: right;">1.02579</td><td style = "text-align: right;">-2.21679</td><td style = "text-align: right;">-1.3344e-16</td><td style = "text-align: right;">-1.97508e-15</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">0.995631</td><td style = "text-align: right;">-3.98881</td><td style = "text-align: right;">-1.25</td><td style = "text-align: right;">-0.5</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">6</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">1.01265</td><td style = "text-align: right;">-3.6874</td><td style = "text-align: right;">-0.9</td><td style = "text-align: right;">-0.3</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">7</td><td style = "text-align: left;">bus7</td><td style = "text-align: right;">1.02577</td><td style = "text-align: right;">3.7197</td><td style = "text-align: right;">-1.22829e-16</td><td style = "text-align: right;">1.88932e-15</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">8</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">1.01588</td><td style = "text-align: right;">0.727536</td><td style = "text-align: right;">-1.0</td><td style = "text-align: right;">-0.35</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">9</td><td style = "text-align: left;">bus9</td><td style = "text-align: right;">1.03235</td><td style = "text-align: right;">1.96672</td><td style = "text-align: right;">-8.67741e-17</td><td style = "text-align: right;">8.57133e-16</td></tr></tbody></table></div><pre><code class="language-julia hljs">show_powerflow(pfs_rot)</code></pre><div><div style = "float: left;"><span>9×6 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">N</th><th style = "text-align: left;">Bus Names</th><th style = "text-align: left;">vm [pu]</th><th style = "text-align: left;">varg [deg]</th><th style = "text-align: left;">P [pu]</th><th style = "text-align: left;">Q [pu]</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Symbol" style = "text-align: left;">Symbol</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">1</td><td style = "text-align: left;">slackbus</td><td style = "text-align: right;">1.04</td><td style = "text-align: right;">30.0</td><td style = "text-align: right;">0.71641</td><td style = "text-align: right;">0.270459</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">2</td><td style = "text-align: left;">pvbus</td><td style = "text-align: right;">1.025</td><td style = "text-align: right;">39.28</td><td style = "text-align: right;">1.63</td><td style = "text-align: right;">0.0665366</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">3</td><td style = "text-align: left;">pvbus</td><td style = "text-align: right;">1.025</td><td style = "text-align: right;">34.6648</td><td style = "text-align: right;">0.85</td><td style = "text-align: right;">-0.108597</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">4</td><td style = "text-align: left;">bus4</td><td style = "text-align: right;">1.02579</td><td style = "text-align: right;">27.7832</td><td style = "text-align: right;">8.83235e-16</td><td style = "text-align: right;">-2.10461e-16</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">0.995631</td><td style = "text-align: right;">26.0112</td><td style = "text-align: right;">-1.25</td><td style = "text-align: right;">-0.5</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">6</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">1.01265</td><td style = "text-align: right;">26.3126</td><td style = "text-align: right;">-0.9</td><td style = "text-align: right;">-0.3</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">7</td><td style = "text-align: left;">bus7</td><td style = "text-align: right;">1.02577</td><td style = "text-align: right;">33.7197</td><td style = "text-align: right;">2.46441e-15</td><td style = "text-align: right;">-1.43587e-15</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">8</td><td style = "text-align: left;">pqbus</td><td style = "text-align: right;">1.01588</td><td style = "text-align: right;">30.7275</td><td style = "text-align: right;">-1.0</td><td style = "text-align: right;">-0.35</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">9</td><td style = "text-align: left;">bus9</td><td style = "text-align: right;">1.03235</td><td style = "text-align: right;">31.9667</td><td style = "text-align: right;">-1.26285e-15</td><td style = "text-align: right;">3.21428e-15</td></tr></tbody></table></div><h2 id="Reference-Simulation-with-Nonlinear-Models"><a class="docs-heading-anchor" href="#Reference-Simulation-with-Nonlinear-Models">Reference Simulation with Nonlinear Models</a><a id="Reference-Simulation-with-Nonlinear-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-Simulation-with-Nonlinear-Models" title="Permalink"></a></h2><p>To establish a reference solution, we simulate a line trip contingency using the full nonlinear models. This will serve as our benchmark for comparing the linearized model accuracy.</p><p>We initialize the network from both powerflow states (with and without phase shift) and simulate the system response over 10 seconds.</p><pre><code class="language-julia hljs"># Perturbation: line failure of 4=&gt;6 at t=1s
deactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx
    p[:pibranch₊active] = 0
end
cb = PresetTimeComponentCallback([1.0], deactivate_line)
set_callback!(nw[EIndex(4=&gt;6)], cb)

# steady states for both rotated and non-rotated case
s0 = initialize_from_pf(nw; pfs=pfs)
s0_rot = initialize_from_pf(nw; pfs=pfs_rot)

# simulation of both rotated and non-rotated case
prob = ODEProblem(nw, uflat(s0), (0.0, 10.0), copy(pflat(s0)), callback=get_callbacks(nw))
sol = solve(prob, Rodas5P());

prob_rot = ODEProblem(nw, uflat(s0_rot), (0.0, 10.0), copy(pflat(s0_rot)), callback=get_callbacks(nw))
sol_rot = solve(prob_rot, Rodas5P());

# Verify that the solutions differ by exactly the phase shift
@assert sol_rot(0; idxs=VIndex(1,:busbar₊u_arg)) - sol(0; idxs=VIndex(1,:busbar₊u_arg)) ≈ deg2rad(30)

# Plotting results
let
    fig = Figure(size=(600,800));

    # Active power at selected buses
    ax = Axis(fig[1, 1]; title=&quot;Active Power&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Power [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.5)
        lines!(ax, sol_rot; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
    end

    # Voltage magnitude at all buses
    ax = Axis(fig[2, 1]; title=&quot;Voltage Magnitude&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Voltage [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.5)
        lines!(ax, sol_rot; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
    end

    fig
end</code></pre><img src="ece69bec.png" alt="Example block output"/><p>As expected, both voltage magnitudes and active power profiles are identical for both cases. This confirms that these quantities are indeed invariant under global phase shifts.</p><h2 id="Complete-System-Linearization"><a class="docs-heading-anchor" href="#Complete-System-Linearization">Complete System Linearization</a><a id="Complete-System-Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-System-Linearization" title="Permalink"></a></h2><p>Now we proceed to linearize all dynamic components around their respective operating points. This involves computing the Normal Form linearization for each component using the steady-state conditions we established above.</p><pre><code class="language-julia hljs"># Helper function to extract component state from network state
function get_component_state(s::NWState, cidx)
    nw = extract_nw(s)
    comp = nw[cidx]
    allsym = vcat(sym(comp), psym(comp), insym(comp), outsym(comp))
    Dict(sym =&gt; s[VIndex(cidx.compidx, sym)] for sym in allsym)
end</code></pre><p>We apply the Normal Form linearization procedure to each of the 9 bus components, computing the linearized dynamics around their respective operating points:</p><pre><code class="language-julia hljs">vms_lin = map(1:9) do i
    nonlinear_model = nw[VIndex(i)]
    comp_state = get_component_state(s0, VIndex(i))
    nf_linearization(nonlinear_model, comp_state)
end;
nw_lin = Network(nw; vertexm=vms_lin)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 54 states and 945 parameters
 ├─ 9 vertices (2 unique types)
 └─ 9 edges (2 unique types)
Edge-Aggregation using SequentialAggregator(+)
1 callback set across 0 vertices and 1 edge</code></pre><p>The linearized network is then initialized using both the original and phase-shifted powerflow states. By simulating both cases, we can verify whether the linearized models preserve the rotational invariance property of the original nonlinear system:</p><pre><code class="language-julia hljs">s0_lin = initialize_from_pf(nw_lin; pfs=pfs);
prob_lin = ODEProblem(nw_lin, uflat(s0_lin), (0.0, 10.0), copy(pflat(s0_lin)), callback=get_callbacks(nw_lin))
sol_lin = solve(prob_lin, Rodas5P());

s0_lin_rot = initialize_from_pf(nw_lin; pfs=pfs_rot);
prob_lin_rot = ODEProblem(nw_lin, uflat(s0_lin_rot), (0.0, 10.0), copy(pflat(s0_lin_rot)), callback=get_callbacks(nw_lin))
sol_lin_rot = solve(prob_lin_rot, Rodas5P());

let
    fig = Figure(size=(600,800));

    # Active power at selected buses
    ax = Axis(fig[1, 1]; title=&quot;Active Power&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Power [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.3)
        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
        lines!(ax, sol_lin_rot; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), linewidth=0.5)
    end

    # Voltage magnitude at all buses
    ax = Axis(fig[2, 1]; title=&quot;Voltage Magnitude&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Voltage [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.3)
        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
        lines!(ax, sol_lin_rot; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), linewidth=0.5)
    end

    fig
end</code></pre><img src="e43b3839.png" alt="Example block output"/><p>The plot displays three overlapping traces for each bus (same color per bus):</p><ul><li><strong>Transparent solid line</strong>: Original nonlinear model</li><li><strong>Dashed line</strong>: Linearized model initialized from non-rotated powerflow</li><li><strong>Thin solid line</strong>: Linearized model initialized from rotated powerflow</li></ul><p>The agreement between the two normal furm curves demostrate, that the linearization in invariant coordinates keeps the global phase shift symmetry.</p><h2 id="Excursion:-Rotational-Symmetry-Analysis"><a class="docs-heading-anchor" href="#Excursion:-Rotational-Symmetry-Analysis">Excursion: Rotational Symmetry Analysis</a><a id="Excursion:-Rotational-Symmetry-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Excursion:-Rotational-Symmetry-Analysis" title="Permalink"></a></h2><p>In the original generator model, the machine angle δ is covariant (it transforms along with global phase shifts). We can verify this numerically by applying a rotation to all relevant variables and checking that the steady-state residual remains zero:</p><pre><code class="language-julia hljs">rotational_symmetry(nw[VIndex(1)], get_component_state(s0, VIndex(1));
    covariant=[:generator₊machine₊δ])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">Performed rotational symmetry analysis 360 angles.</span>
 - input current and output voltage was rotated and the residual of the steady state was calculated for each angle.
 - assume covariant variables generator₊machine₊δ transform like δ → δ + Δδ
<span class="sgr32">✓ All residuals are below 1.0e-6</span></code></pre><p>In the linearized Normal Form model, the covariant variable is the initial phase angle Θ₀_i, while the rest of the states remain invariant.</p><pre><code class="language-julia hljs">rotational_symmetry(nw_lin[VIndex(1)], get_component_state(s0_lin, VIndex(1));
    covariant=[:Θ₀_i])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">Performed rotational symmetry analysis 360 angles.</span>
 - input current and output voltage was rotated and the residual of the steady state was calculated for each angle.
 - assume covariant variables Θ₀_i transform like δ → δ + Δδ
<span class="sgr32">✓ All residuals are below 1.0e-6</span></code></pre><h2 id="Selective-Linearization:-Generators-Only"><a class="docs-heading-anchor" href="#Selective-Linearization:-Generators-Only">Selective Linearization: Generators Only</a><a id="Selective-Linearization:-Generators-Only-1"></a><a class="docs-heading-anchor-permalink" href="#Selective-Linearization:-Generators-Only" title="Permalink"></a></h2><p>In the previous example, we linearized all system components, including simple Kirchhoff junction buses and PQ load buses that have relatively simple dynamics. For comparison, let&#39;s now create a hybrid model where we linearize only the three generator buses (which have complex dynamics) while keeping the remaining buses in their original nonlinear form.</p><pre><code class="language-julia hljs">vms_lin2 = map(1:9) do i
    if i ∈  [1,2,3]
        nonlinear_model = nw[VIndex(i)]
        comp_state = get_component_state(s0, VIndex(i))
        nf_linearization(nonlinear_model, comp_state)
    else
        copy(nw[VIndex(i)])
    end
end;
nw_lin2 = Network(nw; vertexm=vms_lin2)
s0_lin2 = initialize_from_pf(nw_lin2; pfs=pfs);
prob_lin2 = ODEProblem(nw_lin2, uflat(s0_lin2), (0.0, 10.0), copy(pflat(s0_lin2)), callback=get_callbacks(nw_lin2))
sol_lin2 = solve(prob_lin2, Rodas5P());

let
    fig = Figure(size=(600,800));

    # Active power at selected buses
    ax = Axis(fig[1, 1]; title=&quot;Active Power&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Power [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.3)
        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
        lines!(ax, sol_lin2; idxs=VIndex(i,:busbar₊P), label=&quot;Bus $i&quot;, color=Cycled(i), linewidth=0.5)
    end

    # Voltage magnitude at all buses
    ax = Axis(fig[2, 1]; title=&quot;Voltage Magnitude&quot;, xlabel=&quot;Time [s]&quot;, ylabel=&quot;Voltage [pu]&quot;)
    for i in 1:9
        lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), alpha=0.3)
        lines!(ax, sol_lin; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), linestyle=:dash)
        lines!(ax, sol_lin2; idxs=VIndex(i,:busbar₊u_mag), label=&quot;Bus $i&quot;, color=Cycled(i), linewidth=0.5)
    end

    fig
end</code></pre><img src="dc722533.png" alt="Example block output"/><p>This selective linearization approach yields results that are even closer to the full nonlinear solution. This suggests that linearizing only the components with significant dynamic complexity can provide an optimal balance between computational efficiency and accuracy.</p><h2 id="Computational-Performance-Analysis"><a class="docs-heading-anchor" href="#Computational-Performance-Analysis">Computational Performance Analysis</a><a id="Computational-Performance-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Performance-Analysis" title="Permalink"></a></h2><p>Finally, let&#39;s quantify the computational benefits of linearization by benchmarking the different model variants. We&#39;ll measure both the single function evaluation time and the complete ODE solve performance.</p><pre><code class="language-julia hljs">dx = zeros(dim(nw)); x = copy(uflat(s0)); p = copy(pflat(s0));
@benchmark $nw($dx, $x, $p, 0.0) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.899 μs</span></span> … <span class="sgr35">  4.838 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.915 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.933 μs</span></span> ± <span class="sgr32">125.065 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▇<span class="sgr34">█</span>▂<span class="sgr32"> </span>   ▁                                                    ▁
  █<span class="sgr34">█</span>█<span class="sgr32">▅</span>▅▆██▄▁▃▄▁▃▃▄▅▅▅▄▁▃▁▁▁▁▁▁▃▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅▆██ █
  1.9 μs<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      2.68 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><pre><code class="language-julia hljs">dx = zeros(dim(nw_lin)); x = copy(uflat(s0_lin)); p = copy(pflat(s0_lin));
@benchmark $nw_lin($dx, $x, $p, 0.0) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 9 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.010 μs</span></span> … <span class="sgr35">  4.600 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.026 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.046 μs</span></span> ± <span class="sgr32">138.568 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  █<span class="sgr34">█</span><span class="sgr32">▁</span>   ▁                                                     ▂
  █<span class="sgr34">█</span><span class="sgr32">█</span>▅▇▆██▃▃▄▃▄▄▁▄▄▅▁▅▃▁▄▃▁▃▁▁▁▃▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▃▁▁▁▁▃▃▁▅▃▇██ █
  2.01 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      2.87 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><pre><code class="language-julia hljs">dx = zeros(dim(nw_lin2)); x = copy(uflat(s0_lin2)); p = copy(pflat(s0_lin2));
@benchmark $nw_lin2($dx, $x, $p, 0.0) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.834 μs</span></span> … <span class="sgr35">  5.173 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.851 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.871 μs</span></span> ± <span class="sgr32">133.701 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▆<span class="sgr34">█</span>▄<span class="sgr32"> </span>   ▁                                                    ▁
  █<span class="sgr34">█</span>█<span class="sgr32">▅</span>▄▄▇█▅▃▃▄▁▁▁▄▅▅▄▅▁▃▁▃▁▁▁▁▁▁▁▄▁▃▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▄▅▇██ █
  1.83 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       2.6 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>Next, we benchmark the complete ODE solution process:</p><pre><code class="language-julia hljs">@benchmark solve($prob, Rodas5P()) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 77 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">12.265 ms</span></span> … <span class="sgr35"> 14.160 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">12.743 ms               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">13.033 ms</span></span> ± <span class="sgr32">461.959 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

                ▄█▃▆▄<span class="sgr34"> </span>          <span class="sgr32"> </span>                ▁  ▃▆          
  ▄▁▁▁▁▄▁▁▁▁▁▄▆▇█████<span class="sgr34">▇</span>▄▄▁▁▄▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▄▁▁▁▁▁▄▁▁▁▁▁▄█▆▆██▄▄▄▁▄▄▄▄ ▁
  12.3 ms<span class="sgr90">         Histogram: frequency by time</span>         13.8 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">3.78 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">11788</span>.</code></pre><pre><code class="language-julia hljs">@benchmark solve($prob_lin, Rodas5P()) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 145 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">6.411 ms</span></span> … <span class="sgr35">  7.524 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">7.171 ms               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">6.916 ms</span></span> ± <span class="sgr32">352.431 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

       ▄▄▄▁                    <span class="sgr32"> </span>              <span class="sgr34">▆</span>█▃              
  ▄▄▃▄▅████▄▁▃▅▃▃▁▁▄▃▄▁▁▁▁▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁▁▁▁▄▄▆<span class="sgr34">█</span>██▇▆▅▆▃▄▁▃▃▃▃▄ ▃
  6.41 ms<span class="sgr90">         Histogram: frequency by time</span>        7.44 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">1.86 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1810</span>.</code></pre><pre><code class="language-julia hljs">@benchmark solve($prob_lin2, Rodas5P()) seconds=1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 39 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">24.160 ms</span></span> … <span class="sgr35">27.906 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">26.835 ms              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">25.980 ms</span></span> ± <span class="sgr32"> 1.254 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

      ▁                        <span class="sgr32"> </span>            <span class="sgr34">█</span>▁                 
  ▆▄▁▇█▄▄▁▁▄▁▄▄▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁▁▁▁▆<span class="sgr34">█</span>█▆▄▇▆▁▁▁▁▁▁▁▁▁▁▄ ▁
  24.2 ms<span class="sgr90">         Histogram: frequency by time</span>        27.9 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">7.07 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">6610</span>.</code></pre><p>The results here are... inconclusive. For this system there is no real benefit in linearizing.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../droop_identification/">« Droop Identification</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 25 August 2025 13:51">Monday 25 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
